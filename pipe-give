#!/bin/bash

trap callstack ERR

set -o errexit \
    -o pipefail \
    -o nounset

global_msg_level=4

function msg() {
    if [[ "$#" -ne 2 ]]; then
        printf "[%s] %s: (%s) %s" "$(logdate)" "$0" "fatal" "incorrect number of arguments provided to msg function"
        exit 1
    fi

    local level="$1"
    local message="$2"
    local active_level="${global_msg_level:-none}"

    local -A levels=([none]=0 [fatal]=1 [error]=2 [warn]=3 [info]=4 [debug]=5)
    local num_level="${levels[$level]}"
    local num_active_level="${levels[$active_level]}"

    if [[ "$num_level" -le "${num_active_level}" ]]; then
        printf "[%s] %s: (%s) %s\n" "$(logdate)" "$0" "$level" "$message" >&2
    fi
    if [[ "$level" == "fatal" ]]; then
        callstack
    fi
}

function callstack() {
    echo --- Trace: ---
    local i
    # These arrays start at index 0, but 0 is this callstack function, so skip it.
    for ((i=1; i<${#FUNCNAME[*]}; i++)) do
        if [[ $i -ne 1 ]]; then
            echo -n "  "  
        fi
        echo "${BASH_SOURCE[$i]}: in \"${FUNCNAME[$i]}\" called from line ${BASH_LINENO[$i]}"
    done
    echo --------------
    exit 1
}

function cleanup_dir() {
    if [[ -d "$fifo_dir" ]]; then
        rm -rf -- "${fifo_dir}"
    fi
}

function must_have_cmds() {
    for cmd in "$@"; do
        command -v "$cmd" >/dev/null 2>/dev/null || msg fatal "this script needs a working copy of '$cmd' but could not find one"
    done
}

must_have_cmds tar mkfifo mktemp stat



# TODO: improve
if [[ "$#" -eq 0 ]] || [[ "$1" == "-h" ]]; then
    echo "Usage: $0 [files]" >&2
    exit 0
fi

# Allow use of alternative temporary directories, but...
tmpdir="${TMPDIR:-/tmp}"

# ... check the TMPDIR has the permissions we need.
tmpdir_perms="$(stat --printf=%a -- "$tmpdir")"

if [[ "$tmpdir_perms" != "1777" ]]; then
    msg fatal "cannot use TMPDIR to transfer data, does not have appropriate permissions"
fi

fifo_dir="$(mktemp -d -p "$tmpdir" -t "pipe-transfer.XXXXXXXX")"
fifo_suffix="${fifo_dir##*.}"

# If we get interrupted or finish, remove the fifo directory
trap cleanup_dir EXIT

# Make one for password and info, one for transferring data.
# It's like we're reinventing ftp woo
mkfifo -- "$fifo_dir/ctrl" "$fifo_dir/data"

if [[ "${RANDOM:-}" == "" ]]; then
    msg fatal "bash random number generator has been broken, cannot continue"
fi

# Make a password to *kind* of authenticate transfers.
transfer_pass="$RANDOM$RANDOM$RANDOM$RANDOM$RANDOM"
transfer_pass="${transfer_pass:1:9}"
printf "
Your transfer ID: %s
    and password: %s

Please enter this at receiver.

Remember you must be on the same node.

    [Ctrl-C to cancel.]
" "$fifo_suffix" "$transfer_pass"


# TODO: use openssl to use password to encrypt sample data, to make this actually secure at all.
# Hm. Since it's a one-time-use credential, I don't *think* it matters.

# Allow several tries.
allow_tries=3
tries=0
correct_pass=0

while [[ "$tries" -lt "$allow_tries" ]]; do
    pass_recv="$(cat -- "$fifo_dir/ctrl")"

    if [[ "$pass_recv" == "$transfer_pass" ]]; then
        correct_pass=1
        break
    else
        msg info "received incorrect transfer password! $(( allow_tries - tries )) tries remaining."
        echo "incorrect password" >"$fifo_dir/ctrl"
        tries="$(( tries + 1 ))"
        continue
    fi
done

if [[ "$correct_pass" == 0 ]]; then
    echo "too many tries" >"$fifo_dir/ctrl"
    msg fatal "maximum number of password attempts exceeded, quitting."
    # Juuuuuust in case msg fatal doesn't exit, for some reason.
    exit 5
fi

# So by this point, we have a correct password, in theory.
echo "correct password" >"$fifo_dir/ctrl"

msg info "correct password received, transferring files..."

tar -cv -- "$@" >"$fifo_dir/data" || msg fatal "there was a problem while transferring the files D:"

msg info "transfer complete"
