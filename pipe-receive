#!/bin/bash

trap callstack ERR

set -o errexit \
    -o pipefail \
    -o nounset

global_msg_level=4

function msg() {
    if [[ "$#" -ne 2 ]]; then
        printf "[%s] %s: (%s) %s" "$(logdate)" "$0" "fatal" "incorrect number of arguments provided to msg function"
        exit 1
    fi

    local level="$1"
    local message="$2"
    local active_level="${global_msg_level:-none}"

    local -A levels=([none]=0 [fatal]=1 [error]=2 [warn]=3 [info]=4 [debug]=5)
    local num_level="${levels[$level]}"
    local num_active_level="${levels[$active_level]}"

    if [[ "$num_level" -le "${num_active_level}" ]]; then
        printf "[%s] %s: (%s) %s\n" "$(logdate)" "$0" "$level" "$message" >&2
    fi
    if [[ "$level" == "fatal" ]]; then
        callstack
    fi
}

function callstack() {
    echo --- Trace: ---
    local i
    # These arrays start at index 0, but 0 is this callstack function, so skip it.
    for ((i=1; i<${#FUNCNAME[*]}; i++)) do
        if [[ $i -ne 1 ]]; then
            echo -n "  "  
        fi
        echo "${BASH_SOURCE[$i]}: in \"${FUNCNAME[$i]}\" called from line ${BASH_LINENO[$i]}"
    done
    echo --------------
    exit 1
}

function must_have_cmds() {
    for cmd in "$@"; do
        command -v "$cmd" >/dev/null 2>/dev/null || msg fatal "this script needs a working copy of '$cmd' but could not find one"
    done
}

must_have_cmds tar


###########

# Arg Parsing -- not a lot

help_message="
usage: $0 [-h|-d] 

A script to quickly receive files from another user on the same node.

The user you are receiving the file from should run the equivalent give
 command, and should tell you the ID and password for the transfer.

This script will request the ID and password from you when you run it.

Transfer passwords are single-use, so don't worry about sharing them
 with someone else.

Note that this will not overwrite files with the same name you already
 have: if you have a file in the current directory called \"my_file\"
 and someone gives you a file called \"my_file\", this will be treated
 as an error.

Flags:
   -h, --help        Show this help.
   -d, --debug       Debug mode.
"


function show_help_and_exit() {
    printf "%s" "$help_message"
    exit "${1:-0}"
}

canonical_args="$(
/usr/bin/getopt \
    -n pipe-receive \
    -l "help,debug" \
    -o "hd" \
    -- \
    "$@"
)"

eval set -- "$canonical_args"

# Defaults
debug_mode="false"

while true ; do
    case "$1" in
        -h|--help) show_help_and_exit 0; shift ;;
        -d|--debug) debug_mode="true"; shift ;;
        --) shift ; break ;;
        *) msg fatal "invalid argument '$1'" ; exit 1 ;;
    esac
done

if [[ "$debug_mode" == "true" ]]; then
  # We don't have a proper debug mode, so just set the bash tracing options.
  set -v -x
fi


##########

# Okay, that's all the setup handled.



read -r -p "Please enter your transfer ID: " transfer_id 

transfer_fifo_dir="${TMPDIR:-/tmp}/pipe-transfer.$transfer_id"

if [[ ! -d "$transfer_fifo_dir" ]]; then
    msg fatal "could not find a transfer with that id"
fi

# Got ID, try password
result="incorrect password"

# TODO: Improve this logic
while [[ "$result" == "incorrect password" ]]; do
    read -r -p "Please enter transfer password: " transfer_password

    echo "$transfer_password" >"$transfer_fifo_dir/ctrl"

    result="$(cat "$transfer_fifo_dir/ctrl")"
done

if [[ "$result" != "correct password" ]]; then
    if [[ "$result" == "too many tries" ]]; then
        msg fatal "too many incorrect password attempts, quitting"
    else
        msg fatal "unknown status: $result"
    fi
fi

# So by this point we've either quit, or passed a correct password.

msg info "password correct, receiving files"

tar -xvk <"$transfer_fifo_dir/data" || msg fatal "there was a problem transferring the files D:"

msg info "transfer complete\n"
